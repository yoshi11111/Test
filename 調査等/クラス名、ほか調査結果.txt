■常になんらかの、調査や考えなきゃいけないことで時間が少しでもかかると感じたら、
TODOにして土日に投げる。土日調査したら一瞬でとける



■クラス名
HeaderData 
→そもそもdata:に指定するから、Dataで、データに設定するクラスと一発でわかる
S0600Data
→Entityでまとまっている以上、DataModelなどにしたらちょうふくする
※※※※前例のクラス名は一応踏襲※※※※※※※※


data　→jsonにするものは全てこれで問題ないはず

■メソッド名
doPost→requestServ  [WebMethod]RequestServ 
doUpdate→DoUpdate （ほかのプロジェクトでもこれあったし何の問題もない）
request(POTST_TYPE_NAME);

■DBaccessを別ファイルにする場合どういう構成か
https://itsakura.com/java-dto-dao
https://qiita.com/csharpisthebest/items/403d40374acc70ef24e3
場所以外は決まった
  ■プライベートでnewしてもっておき、それを通して使う
  private Dao _dao = new Dao();
public void main(){
      // DBを更新する。
      _dao.Update(param);
}
  ■クラス名は〇〇DAO
  ■自分自身でS0600のdao使用するため、Commonにするか、もしくはGuidanceか、Masterか
    Masterにしたらメソッド量えぐそうだけど
    でも、S0600Daoもあってもいいんだけど、共有したほうがいい確実に。てかおれがいろいろな画面で使うしそもそも
    guidancemaster,とかでわけよう
    GuidanceMasterDaoクラス

  ■ファイルを保存する場所・・・・
  DAOというフォルダ作るのが一つ。ていうか普通に考えてそれでいい。わざわざEntittyクラスに入れる意味が分からん。
  
  
  
・・・・ファイルは基本的にはModelフォルダに入る。たｄentity/・・・


SyainDao クラスの中の、
    public List<SyainDto> findAll(　メソッド内で、
    select文発行と、執行している

SyainDao syainDao = new SyainDao();
    	List<SyainDto> sd = syainDao.findAll();
    	new して、それを変数として持ち、使う形。
    	なので、S0600DAOもしくは、共通化するのなら、
    	CommonもしくはGUIDANCEMASTR DAOに処理全部まとめてもいい気はする。
    	使えるものがあったら使う感じ





→というか、コメントは全て放置でいい。
  　→コメント全放置で、残りのタスクはコメントと、
  　　見た目関連、という状況にすればいいだけ
■■■■■■■■■■■■■■■■■■■■
「内部設計書のまま実装」で一瞬でも手が止まったら、TODO書いて土日考える、調査する事に記述して、放置。その時は何時間も無駄になる。土日なら一瞬で解決する
コメントで迷った箇所も土日考える
■■■■■■■■■■■■■■■■■■■■


【TODO】４．ルーティング→過去のソースと同じ方法でルーティングを行う。前例踏襲でいい
【TODO】５．trycatch  rollback
以下のような方法で、かつconnectionをずっと使いまわす方法（ロールバック必要、ﾊﾟﾌｫｰﾏﾝｽ的にもconは上位で作成。）
または、すでにコミットされている内容から、connだけ使いまわせる形にカスタム
namespace CSharpSQLServerTransaction
{
    class Program
    {
        // データベース接続文字列
        private static readonly string ConnectionString = "Data Source=<ホスト名、またはIPアドレス>; Initial Catalog=SampleDB; User Id=SampleUser; Password=SamplePassword;";
        // データ更新のSQL
        private static readonly string UpdateSql = "UPDATE person SET name=@name WHERE id=@id";
        static void Main(string[] args)
        {
            try
            {
                // コネクションを生成します。
                using (var connection = new SqlConnection(ConnectionString))
                // コマンドオブジェクトを作成します。
                using (var command = connection.CreateCommand())
                {
                    SqlTransaction transaction = null;
                    try
                    {
                        // コネクションをオープンします。
                        connection.Open();
                        // トランザクションを開始します。
                        transaction = connection.BeginTransaction();
                        // データ更新のSQLを実行します。
                        command.CommandText = UpdateSql;
                        command.Parameters.Add(new SqlParameter("@name", "jiro"));
                        command.Parameters.Add(new SqlParameter("@id", 2));
                        var result = command.ExecuteNonQuery();
                        // 実行された結果が1行ではない場合
                        if (result != 1)
                        {
                            Console.WriteLine("データを更新できませんでした。");
                            // ロールバックします。
                            transaction.Rollback();
                            return;
                        }
                        // コミットします。
                        transaction.Commit();
                    }
                    // データベース操作で例外が発生した場合
                    catch (Exception e)
                    {
                        // 例外の内容を表示します。
                        Console.WriteLine(e.Message);
                        // トランザクションが有効な場合
                        if (transaction != null)
                        {
                            // ロールバックします。
                            transaction.Rollback();
                        }
                    }
                }
            }
            // コネクションオブジェクト、コマンドオブジェクトの生成で例外が発生した場合
            catch (Exception e)
            {
                // 例外の内容を表示します。
                Console.WriteLine(e.Message);
            }
            Console.ReadKey();
        }
    }
}



<<<<Vue.JS>>>

スクリプトタグbodyの手前に実装
templateタグを使う（特にv-for,v-ifの場合）
v-forで固まりを扱う場合はkeyプロパティでdataと紐づける
v-forは必ずkey属性を使用しなければならない＋key属性はtemplateタグは不可能


       
　集中方法と可視化方法記録方法
【TODO】
　→まずは30分ごと、むりなら1hごと①WBS進捗度〇△×②その原因・要因③後回しにするTODO、メモ④PCとスマホルール
　（WBSの進捗中心の思考と原因の明確化が重要）


■■まずは対策ではなく、可視化。記録。それで原因明確になってから、対策　　　
30分ごとに、もしくは1時間ごとに集中度（〇△×）と、その原因、要因を書く→これよりもまずは、WBS進捗への意識の集中重要
・30分ごとにやること変える系→あまりよくない
・30分ごとにろけちゃ対応・・・後の話
・定時後にろけちゃ関連の対応・・・後の話



<<<DB関連>>>
■EntityFrameworkは使用中止
　→ただでさえ遅いという報告多数あり。しかもバージョンめちゃふるいのしか使えない。
　　　後でめちゃくちゃﾊﾟﾌｫｰﾏﾝｽやばいってなるかもしれない
↓
今のところ、Datasetの自動生成＋DBNULLを確認不要の以下
 value =  dr.Field<string>("TITLE");


http://endok.hatenablog.com/entry/2018/01/02/142050
■.netのDBは４つ
×ADO.NET SqlClient
　→SqlDataReaderはreader[0]とかやばすぎ。直値丸出しはやばい。
　　　だからと言って、全カラムのenum定義も手間がかかる。
【確定】ADO.NET DataSet+型指定データセット自動生成
×使用しない　　EntityFramework
×やめたほうがいい。サードパーティnuget。.net3.5に使えるバージョンに不具合あったら詰みDapper
  →しかもdapperはentityは手動で作る必要があり自動生成無し
  
↓
ADO.NET DataSet+型指定データセット自動生成　に確定
→まずはデータセットを定義し、使用し、
土日追加調査で修正されるとしてもdatasetのまとまりや使い方のみだから定義していい


